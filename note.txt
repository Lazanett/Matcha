DATABASE
creation d'un docker pour contenir la base de donnee mysql 
car pas de droit sudo a 42

* creer un docker compose
* lancer le docker : docker-compose up -d
* eteindre le docker : docker-compose down

creation database :

1 Lancer le docker = docker compose up -d
2 lister les dockers (etre sur qu'il est lancer) = docker ps
3 Connexion MYSQL = docker exec -it matcha_mysql mysql -u matcha_user -p
  (mot de passe : matcha_password)

4 Arreter le docker = (avant quitter mysql avec "exit;")
                    = docker compose down
                    = si marche pas = docker stop matcha_mysql


Réinitialisation complète (tt donnee) = docker compose down -v


Liste les volumes Docker = docker volume ls 
Voir où le volume est stocké = docker volume inspect mysql_data 

VOIR LOGS = docker compose logs -f

==========================================================================
liste : id, name, prenom, pseudo, email, genre(f/M/O), SexualPref, age, password, 
        nblike, tags, famerating, biography, location.

==========================================================================
                      JWT (JSON Web Token) 

jeton sécurisé qui permet d'authentifier un utilisateur sans 
stocker son état côté serveur. tilisé pour la connexion des 
utilisateurs et la gestion des permissions.

Quand un utilisateur se connecte, le serveur génère un JWT, qui 
est ensuite envoyé au client (navigateur, application mobile, etc.).
À chaque requête protégée, le client envoie ce token pour prouver 
son identité.

STRUCTURATION 

JWT = chaîne de caractères encodée 3 parties, séparées par des points 
  ex = xxxxxxxx.yyyyyyyy.zzzzzzzz
        |          |          |
      HEADER    PLAYLOAD    SIGNATURE
        |          |          |
        |          |          |
        |          |      (verif authenticiter)
        |          |
        |  (donnee utilisateur: ID...)
        |
(info algo utiliser)
=========================================================================
                    THUNDER client

Sert a verif si requete sur base de donnee.
Pas postman car pas droit sudo donc pas arriver a instalation, 
1 Changer la methode (post, get),
2 Mettre d'url (ex : http://localhost:5000/auth/signup)
3 Aller de "Body" -> JSON et mettre un contenu
4 Appuyer sur 'SEND'


==========================================================================
                     AUTHENTIFICATION

✅ Créer un utilisateur avec un UUID unique lors de l'inscription.
✅ Stocker l'utilisateur en base de données avec un mot de passe hashé.
✅ Générer un JWT contenant l'UUID de l'utilisateur lors de la connexion.
✅ Vérifier le JWT avec un middleware et protéger une route.
✅ Accéder à ta route protégée et voir l'UUID de l'utilisateur authentifié.




✅ S'inscrire avec email et mot de passe (sujet le demande) 
✅ Inscription puis login puis update info profile (profile full)
✅ Protection de toutes les routes (middleware) dans arg des routes

✅ Creation tags avec tags tables et user_tags qui relier les utilisateur 
   et les tags via l'id des user et id des tags (requete api et sql ok)
✅ profile_complet si tt les champs sont rempli ainsi que les tags

A FAIRE = docker rendre permanent tables (et ses donnees) dans matcha
          Faire un script qui creer des utilisateurs random dans matcha
===========================================================================
                CREATIONS TABLES user/utilisateurs

CREATE TABLE utilisateurs (
    id INT AUTO_INCREMENT PRIMARY KEY,
    uuid VARCHAR(36) NOT NULL UNIQUE,
    email VARCHAR(255) NOT NULL UNIQUE,
    mot_de_passe VARCHAR(255) NOT NULL,
    nom VARCHAR(100),
    prenom VARCHAR(100),
    pseudo VARCHAR(50) UNIQUE,
    age INT CHECK (age >= 18),
    genre ENUM('F', 'M', 'O') NOT NULL DEFAULT 'O',
    orientation ENUM('F', 'M', 'O') NOT NULL DEFAULT 'O,
    profil_complet BOOLEAN DEFAULT FALSE
);

{
  "nom": "test",
  "prenom": "test",
  "pseudo": "test23",
  "age": 25,
  "genre": "M",
  "orientation": "F"
}

==========================================================================
                          MATCHING

SUJET = regarder genre de la personne et voir son orientation si O = F/M
- La même zone géographique que l'utilisateur.
- Un maximum de tags communs.
- Un maximum d'indices de notoriété.

recommander d'abord mm zone géographique
ensuite : par l'age, zone geo, framerating et common tags

doit pouvoir METTRE DES FILTRES DANS LA RECHERCHE : - age, 
                                                    - zone geo,
                                                    - framerating,
                                                    - tags.

=========================================================================
              ASSOCIATION TAGS ID ET ID D'UN UTILISATEUR

1 ==> Creation table UTILISATEURS == CREATE TABLE utilisateurs (
                               id INT AUTO_INCREMENT PRIMARY KEY,
                               uuid VARCHAR(36) NOT NULL UNIQUE,
                               email VARCHAR(255) NOT NULL UNIQUE,    
                               mot_de_passe VARCHAR(255) NOT NULL, 
                               nom VARCHAR(100),     prenom VARCHAR(100),
                               pseudo VARCHAR(50) UNIQUE,
                               age INT CHECK (age >= 18),
                               genre ENUM('F', 'M', 'O') NOT NULL DEFAULT 'O',
                               orientation ENUM('F', 'M', 'O') NOT NULL DEFAULT 'O',
                               profil_complet BOOLEAN DEFAULT FALSE );

2 ==> Creation table TAGS == create table tags (
                        id varchar(36) not null,
                        name varchar(255), primary key (id),
                        unique(id));

3 ==> Creation table user_tags(lien entre utlisateurs id et tags id)
create table user_tags (
userId varchar(36) not null references users(id),
tagId varchar(36) not null references tags(id),
primary key(userId, tagId));

4 ==> Creer des utlisateurs dans utlisateurs (via sql ou requete api)

5 ==> Creer des tags dans tags ==
INSERT INTO tags (id, name) VALUES 
(UUID(), 'Netflix'),
(UUID(), 'Lecture'),
(UUID(), 'Vegan'),
(UUID(), 'Geek'),
(UUID(), 'Tatouage'),
(UUID(), 'Piercing'),
(UUID(), 'Sport');

6 ==> ASSOCIER ID USER ET ID TAGS 
     |
     |    Recup id utlisateurs :
     ---> SELECT id FROM users WHERE pseudo = 'pseudo du user';
     |    (renvoie id -> exemple '1')
     |
     |    Recup id tags :
     ---> SELECT id FROM tags WHERE name IN ('Netflix', 'Sport', 'Lecture');
     |    (renvoie id -> exemple '987654321', '12345', '67890)
     |
     |    Association tags/utlisateurs : Netflix id = '987654321'
     ---> INSERT INTO user_tags (userId, tagId) VALUES 
         ('1', '987654321');
            |            |
            |            |
            |        ID tag netflix
            |    
          ID utilisateur

     |
     |
     |    Verrf tag associer a utlisateurs
     ---> SELECT tags.name 
          FROM user_tags 
          JOIN tags ON user_tags.tagId = tags.id
          WHERE user_tags.userId = '1';
                                    |
                                ID utilisateur
          (renvoie 'netflix')

====================================================================================
J'en suis a l'etape ou je dois faire l'algo de matching entre les 
profils pour mon site de rencontre. d'apres le sujet je dois me 
baser sur 3 criteres :
◦ La même zone géographique que l'utilisateur.
◦ Un maximum de tags communs.
◦ Un maximum d'indices de notoriété. 
Je vais m'attaquer a contabiliser les tags commun entre les profils 
de la bases de donnee etre profils "demandeur de match".  
dans ma tables user_tags c'est la que j'associe l'id des utilisateur 
et les id des tags. 
dans un premier temps j'aimerai creer un nouveau fichier ou il y a 
un fonction pour determiner qui est le "profil demandeur de match", 
le genre de personne qui recherche qui est contenu dans le champ 
orientation dans utlilisateur.
puis une fonction qui cherche dans la base de donnee user_tags le nombre de tags en commun avec 